---
title: "Wprowadzenie do obliczeń kwantowych"
---

> Nature isn’t classical, dammit, and if you want to make a simulation of Nature, you’d better make it quantum mechanical, and by golly it’s a wonderful problem because it doesn’t look so easy.  
> **Richard Feynman**


Celem tego wykładu jest zrozumienie, czym są:

1. [Obliczenia Kwantowe](https://pennylane.ai/qml/what-is-quantum-computing) oraz 
2. [Kwantowe Uczenie Maszynowe](https://pennylane.ai/qml/whatisqml) i 
3. dlaczego są one interesujące dla [analityków danych](https://pennylane.ai/blog/2022/03/why-measuring-performance-is-our-biggest-blind-spot-in-quantum-machine-learning/).


**Quntum Machine Learning**

> Co oznacza termin _kwantowe uczenie maszynowe_?

## Uczenie maszynowe

**Uczenie maszynowe** (ale również AI i uczenie głębokie) to nauka i ,,sztuka'' opisująca jak sprawić by komputery mogły _,,uczyć się''_ na podstawie danych,
tak by rozwiązać problemy, których typowe programowanie nie miałoby sensu (lub byłoby zbyt skomplikowane).

> In 1959, Arthur Samuel:
> 
> **a field of study that gives computers the ability to learn without being explicitly programmed**. 


### Dane

<img src="../img/dataml.jpg" width="70%" height="auto" alt="Opis obrazu">


### Modele 

<img src="../img/mlmodels.jpg" width="70%" height="auto"  alt="Opis obrazu">

1. **Uczenie nadzorowane** (ang. _supervised learning_) - posiadając oznaczone dane $(x_i, y_i)$
szukamy funkcji $f(x_i) = y_i$ tak by uogólnić ją na nowe dane. Np. dać kredyt, czy na obrazie jest kot albo pies itp. 

2. **Uczenie nienadzorowane** (ang. _unsupervised learning_) - posiadając dane $(x_i)$ szukamy ukrytych struktur w danych.

3. **Uczenie przez wzmacnianie** (ang. _reinforcement learning_) - agent uczy się realizować zadania w środowisku na podstawie nagród i kar.

Jednym z podstawowych celów uczenia maszynowego (a takze i głębokiego), jest przypisanie klasy (target, labels) dla nowych, nieoznakowanych danych.

Istnieją dwa główne typy dla tego zadania:

- Regresja  – przewidywanie wartości ciągłej,
- klasyfikacja - przewidywanie wartości dyskretnej.

### Funkcja straty 

Funkcja straty mierzy jak przewidywania modelu są oddalone od rzeczywistych wartości. 

1. Pomaga optymalizować parametry modelu przez mechanizm propagacji wstecz 
2. Pozwala na dopasowanie modelu do danych
3. Mniejsza wartość funkcji straty = lepsza jakość modelu. 


<img src="../img/lossfunction.jpg" width="70%" height="auto"  alt="Opis obrazu">

<img src="../img/loss2.jpg" width="70%" height="auto"  alt="Opis obrazu">

### Sieci Neuronowe

<img src="../img/nn.png" width="70%" height="auto" alt="Opis obrazu">

1. Model z parametrami do trenowania $f(x;\theta)= \sigma(Wx+b)$ gdzie $\theta= \{W, b\}$
2. Funkcja kosztu $C = \sum_{i} ( f(x_i, \theta)-y_i )^2$
3. Spadek po gradiencie
   - oblicz gradient funkcji kosztu 
   - zaktualizuj parametry $\theta^{t+1} = \theta^{t} - \eta \nabla C$


```{python}
import torch
from torch.autograd import Variable

data = torch.tensor([(0. , 1.), (0.1 , 1.1), (0.2 , 1.2)])

def model(phi, x=None):
    return x*phi

def loss(a, b):
    return torch.abs(a-b) ** 2

def avg_loss(phi):
    c = 0 
    for x, y in data:
        c += loss(model(phi, x=x), y)
    return c

phi_ = Variable(torch.tensor(0.1), requires_grad=True)
opt = torch.optim.Adam([phi_],lr=0.2)

for i in range(5):
    l = avg_loss(phi_)
    print(f"cost: {l}, for phi: {phi_}")
    l.backward()
    opt.step()

```


<img src="../img/ML.png" width="70%" height="auto"  alt="Opis obrazu">


<img src="../img/computers.jpg" width="70%" height="auto"  alt="Opis obrazu">

**Obliczenia kwantowe** opisują przetwarzenie informacji na urządzeniach pracujących zgodnie z zasadami mechaniki kwantowej.

> Uwaga! klasyczne komputery (tranzystory) również działają zgodnie z zasadami mechaniki kwantowej, ale wykonywane operacje opierają się o logikę klasyczną.

Oba kierunki są istotne w procesie przetwarzania danych obecnie i w niedalekiej przyszłości.
Dlatego naturalnym pytaniem jest jak je ze sobą połączyć?

QML to realizowanie metod uczenia maszynowego, które mogą być wykonywane na komputerach kwantowych.

Kwantowe uczenie maszynowe możemy określić jako uczenie maszynowe realizowane na komputerach kwantowych.
Zasadniczym jest pytanie na ile i czy wogóle komputery kwantowe mogą poprawić jakość modeli uczenia maszynowego i czy pozwalają zrealizować coś więcej niż wykorzystanie klasycznych komputerów. 


### Historia MK

Początek Mechaniki Kwantowej związane są z pracami Maxa Plancka (1900) i Alberta Einsteina (1905), 
którzy wprowadzili pojęcie _kwantu_ - czyli najmniejszej porcji energii. 
Dalszy rozwój Mechaniki Kwantowej związany jest z badaniami takich naukowców jak Niels Bohr, Erwin Schrödinger, Louis de Broglie, Heisenberg, Dirac, Feynman i wielu innych.
Pozostałe informacje możesz znaleźć w [artykule o obliczeniach kwantowych](https://medium.com/@warsaw.quantum/czym-są-technologie-kwantowe-13de3f3e4475)

> Informatyków (najczęściej) nie interesuje, w jaki sposób właściwości fizyczne układów są wykorzystywane do przechowywania informacji w komputerze klasycznym. 
> Podobnie, nie muszą się zastanawiać nad fizycznym mechanizmem, za pomocą którego informacja kwantowa jest realizowana w komputerze kwantowym.
> Czy prowadząc samochód zastanawiasz się, jak dokładnie działają wszystkie jego części? A pisząc kod modelu, zastanawiasz się, jak został on zaimplementowany w bibliotece?"
> Informatycy często nie muszą zagłębiać się w szczegóły fizycznej realizacji, skupiając się za to na wydajnym wykorzystaniu technologii komputerowych.


### Historia obliczeń kwantowych

- 1936 Alan Turing opublikował pracę [On Computable Numbers](https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf), która stanowiła istotny krok w kierunku teoretycznych podstaw obliczeń (Hilbert Problems) - universal computing machine [local](/pubs/Turing_Paper_1936.pdf)
- 1976 Roman S. Ingarden - [Quantum Information Theory](https://www.sciencedirect.com/science/article/abs/pii/0034487776900057?via%3Dihub) Roman S. Ingarden wprowadził pojęcie teorii informacji kwantowej, co miało kluczowe znaczenie dla rozwoju komputerów kwantowych.
- 1980 Paul Benioff - Paul Benioff przedstawił teoretyczną koncepcję komputerów kwantowych jako fizycznych systemów, otwierając drzwi do praktycznych implementacji.
- 1981 Richard Feynman - zwrócił uwagę na to, że klasyczne komputery nie są w stanie efektywnie symulować procesów kwantowych.
- 1985 David Deutsch opracował pierwszy opis kwantowej maszyny Turinga i algorytmów przeznaczonych do uruchamiania na komputerach kwantowych, w tym bramek kwantowych.
- 1994 Peter Shor opracował algorytm faktoryzacji liczb w czasie wielomianowym, co miało znaczenie dla kryptografii i bezpieczeństwa informacji. 
- 1996 Lov Grover - Lov Grover stworzył algorytm Grover'a, który okazał się wyjątkowo efektywny w przeszukiwaniu stanów kwantowych.
- 2000 Został zbudowany pierwszy komputer kwantowy (5 qubitów) oparty na nuklearnym rezonansie magnetycznym, co stanowiło ważny krok w rozwoju fizycznych platform komputerów kwantowych.
- 2001 Demonstracja algorytmu Shora potwierdziła praktyczność i znaczenie algorytmów kwantowych.
- 2007 Firma D-Wave dokonała pierwszej sprzedaży komercyjnego komputera kwantowego, co miało wpływ na rozwój technologii komputerów kwantowych w sektorze prywatnym.
- Firma IBM dokonała znaczącego przełomu, pokazując, że klasyczne superkomputery nie są w stanie efektywnie symulować systemów zawierających więcej niż 56 kubitów, co jest znane jako "quantum supremacy."
- 23 października 2019: Google ogłosił uzyskanie tzw. _quantum supremacy_ na 53 kubitach.
- 2020 Zespół Jian-Wei Pana z University of Science and Technology of China dokonał przełomu, realizując 76 fotonowych kubitów na komputerze Jiuzhang.
- 2023 Pierwszy logiczny qubit?
- 2025 [Google Quantum Echoes](https://blog.google/technology/research/quantum-echoes-willow-verifiable-quantum-advantage/)


Od około 1990 roku fizycy i informatycy pracują nad fizyczną realizacją komputerów kwantowych. 
Jednym z popularnych modeli obliczeń na komputerach kwantowych jest model oparty na _kwantowych obwodach_ (ang. quantum circuit), 
który wykorzystuje qubity zamiast klasycznych bitów. 
Podobnie jak w przypadku obwodów klasycznych, w modelu kwantowym definiuje się
_bramki kwantowe_ (ang. quantum gates), które pozwalają na wykonywanie operacji na qubitach.


## Dlaczego chcemy używać komputerów kwantowych?

### Kwantowa złożoność (Quantum Complexity)

Nowy paradygmat wykorzystuje unikalne cechy _interferencji_, 
_superpozycji_ i _splątania_ w celu wykonywania obliczeń.

Obecnie realizowany jest w trzech modelach:

1. **Quantum Circuits** (Obwody Kwantowe) - oparty na modelu bramkowym, pozwala realizować algorytmy typu QAOA, VQA, oraz metody hybrydowe.
2. **Adiabatyczne Obliczenia Kwantowe** (D-Wave) - polegające na minimalizacji energii, z wykorzystaniem optymalizacji QUBO i analogii do modelu Isinga.
3. **Topologiczne Komputery Kwantowe** - oparte na topologicznych kubitach.


Problemy, które uważamy za trudne do rozwiązania klasycznie, takie jak optymalizacja, 
stają się łatwiejsze dla komputerów kwantowych. 
Przykładem moze być faktoryzacja liczb.
Klasyczne komputery nie są w stanie efektywnie symulować działania kwantowych komputerów. 
Koszt najlepszych symulatorów rośnie wykładniczo wraz z liczbą kubitów.
Możliwości komputerów kwantowych są potencjalnie ogromne, ale obecnie istnieją pewne ograniczenia [link](https://medium.com/qiskit/what-can-a-quantum-computer-actually-do-4daed0691f6b).
Kwantowy komputer może być używany do efektywnej symulacji niemal dowolnego procesu fizycznego zachodzącego w przyrodzie, choć nie zawsze jesteśmy pewni, czy taka symulacja jest możliwa.

Podstawowym faktem przewagi komputerów kwantowych nad klasycznymi jest tzw. **parallelizm**. 
Ze względu, iż kubity moga znajdowac się w superpozycji stanów, komputer kwantowy może przeprowadzic obliczenia jednocześnie na wszystkich stanach. 
Co dokładnie to oznacza, poznamy w dalszej czesci wykładu. 
Rozważmy sytuację w której chcemy poznac działanie funkcji $f(x)$ dla pewnego argumentu $x$ (dla pewnej liczby). 
Aby znaleźc wynik dla dwóch liczb (np. $x=0$ i $x=1$) klasyczny komputer musi wykonac dwie operacje. 
Komputer kwantowy może uzuskac ten wynik przeprowadzajac obliczenia jednocześnie dla obu warości. 
Do wykonania takiej operacji wystarczy jeden kubit. 
Następnie jeżeli będziemy chcieli obliczyc nasza funkcję dla kolejnych liczb $x=2$ (która binarnie reprezentowana jest jako $10$) oraz liczby $x=3$ (binarnie $11$) musimy dodac kolejny (jeden!) kubit. 
Dwa kubity moga posłużyc do realizacji czterech równoległych operacji. 
Jeśli rozważymy 3 kubity znowu mozemy podwoic ilośc operacji (3 kubity maja 8 stanów bazowych). 
Dodanie kubitu do komputera kwantowego pozwala podwoic liczbę obliczeń. 
W przypadku klasycznego komputera aby uzyskac taki efekt, potrzeba podwoic rownież liczbę bitów. 
n-kubitów moze realizowac $2^n$ równoległych obliczeń. 

### Kwantowa korekcja błędów (Quantum Error Correction)

Dekoherencja, czyli oddziaływanie z otoczeniem, niszczy stan komputera kwantowego i wprowadza błędy obliczeniowe. 
Istnieje potrzeba zabezpieczenia przed tym zjawiskiem.
Obliczenia kwantowe wymagają tzw. korekcji błędów, która pomaga w utrzymaniu integralności obliczeń na komputerach kwantowych.
Aktualnie mówimy o erze _Noisy Intermediate-Scale Quantum_ (NISQ), co oznacza, że komputery kwantowe wciąż potrzebują rozwoju w zakresie korekcji błędów i stabilności.

### Realizacja fizyczna komputerów kwantowych

[procesory kwantowe](https://en.wikipedia.org/wiki/List_of_quantum_processors)

<img class="center" src="../img/maszyny_kwantowe.png">

### Proces obliczeń kwantowych

Wykonanie obliczeń związane jest z pojęciem fizycznego _doświadczenia_.
Będzie się ono składać z trzech części:

1. przygotowanie (przygotuj stan kwantowy kubitów),
2. ewolucja (przeprowadź transformację za pomocą bramek kwantowych),
3. pomiar i interpretacja wyników.

<img class="center" src="../img/quantum_proces2.png">

Podobnie w informatyce i w analizach danych wykonujemy obliczenia klasyczne. 
przygotowujemy dane (stan początkowy); następnie wykonujemy program (ewolucja) i odczytujemy wyniki (pomiar).

> Nie obserwujemy tych etapów podczas codziennej interakcji z komputerem, więc nie zauważamy w sposób świadomy powyższego schematu działania.
> Piotr Gawron, Oscar Słowik - [Rewolucja Stanu, Fantastyczne wprowadzenie do informatyki kwantowej.](https://depot.ceon.pl/handle/123456789/16807)

Każdy komputer kwantowy (koprocesor) musi komunikować się z podukładem klasycznym.
<img class="center" src="../img/proces_kwantowy.png">

## Quantum Machine Learning

### Klasyczne dane w kwantowym uczeniu maszynowym

<img class="center" src="../img/qml.png">

1. CC - Classical data using classical computers, 
algorytmy [inspirowane obliczeniami kwantowymi](https://dl.acm.org/doi/10.1145/3313276.3316310)

2. QC - Quantum data using classical (ML) computers. [link1](https://www.nature.com/articles/s41524-020-0282-0), 
[link2](https://www.nature.com/articles/s41534-019-0141-3), [link3](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.114.200501)

3. CQ - Classical data on qunatum computers. Na tym chcemy się skupić.

4. QQ - Quantum data on quantum computers. Who knows?

### Dostęp do obliczeń kwantowych w chmurze

- [IBM Quantum](https://www.ibm.com/quantum/access-plans/) z wykorzystaniem biblioteki qiskit.
- [Pennylane](https://pennylane.ai/) z wykorzystaniem biblioteki pennylane.
- [Cirq Google](https://quantumai.google/cirq) z wykorzystaniem biblioteki cirq.
- [D-Wave](https://www.dwavesys.com/build/getting-started/) - Python
- [Xanadu](https://www.xanadu.ai) - Pennylane Python library
- [Amazon braket](https://aws.amazon.com/braket/) - AWS Python, Julia